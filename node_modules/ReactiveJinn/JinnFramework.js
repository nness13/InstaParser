window.thisComponent = {}
window.components = []
window.jhandler = []
window.jprops = {}
window.jstate = {}
DEBUG_FLAG_FRAMEWORK = false

/**
 * Створює компонент з строки в HTML привязує обробники
 *
 * Кожному елементу даємо свій ключ по ньому знаходимо та обновляємо
 */
function createComponent(type, html, dataOldObj = null) {
    let dataNewObj = window.thisComponent = {
        cuuid: dataOldObj ? dataOldObj.cuuid : generateRandomString(),
        type: type,
        domLink: {},
        childComponents: [],
        dependencies: [],
        handlers: [],
        props: dataOldObj ? dataOldObj.props : '',
        status: dataOldObj && dataOldObj.status ? dataOldObj.status : 'new'
    };
    if(DEBUG_FLAG_FRAMEWORK) console.log(window.jprops[dataNewObj.props])
    // console.log('---------------------------------------------------------------------')
    // console.log('window.thisComponent', window.thisComponent)

    if(dataOldObj) unMountComponent(dataOldObj)

    html = html(window.jprops[dataNewObj.props] || {})
    dataNewObj.dependencies = state.dependencies
    state.dependencies = []
    let div = document.createElement('div');

    if(DEBUG_FLAG_FRAMEWORK) console.log('Парсинг внутрішніх компонентів...', type, dataNewObj)
    let regex = /<\s*(?<name>[A-Z][a-zA-Z]+\b)(?<selectors>[0-9A-Za-z="'`:{ }#\[/\].\t]*)\/>/g;
    html = html.replace(regex, (match, name, selectors) => {
        let cuuid = generateRandomString()
        dataNewObj.childComponents.push(cuuid)
        return `<div component="${name}" cuuid="${cuuid}" ${selectors}></div>`;
    });
    if(DEBUG_FLAG_FRAMEWORK) console.log('Результат: html - ', html, ' Внутрішні компоненти - ', dataNewObj.childComponents)

    div.innerHTML = html;
    // div.firstElementChild.setAttribute('cuuid', dataNewObj.cuuid)
    let change = ['click', 'input', 'change', 'keydown', 'keyup',
        'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave']
    let acting = div.querySelectorAll('[j'+change.join('], [j'))
    acting.forEach(tag => {
        change.map(a => {
            if(tag.hasAttribute('j'+a)) {
                if(DEBUG_FLAG_FRAMEWORK) console.log("Подія: ", a, window.jhandler)
                tag.addEventListener(a, window.jhandler[tag.getAttribute('j' + a)])
                dataNewObj.handlers.push(tag.getAttribute('j' + a))
                tag.removeAttribute('j' + a)
            }
        })
    })
    if(DEBUG_FLAG_FRAMEWORK) console.log('Додав події', dataNewObj)

    div.firstElementChild.querySelectorAll('[jfocus]').forEach(i => {
        if(i.getAttribute('jfocus') === document.activeElement.getAttribute('jfocus')){
            console.log(i, document.activeElement)
            useEffect(() => {
                i.focus()
                if(i.selectionStart !== null) i.selectionStart = i.value.length;
            })
        }
    })
    if(dataOldObj && !dataOldObj.drawingUp) {
        let event = new CustomEvent('onUpdate', {detail: {'component': dataOldObj}});
        window.dispatchEvent(event);
    }
    if(dataNewObj.status === 'new') {
        dataNewObj.status = 'create'
        let event = new CustomEvent('onCreate', {detail: {'component': dataNewObj}});
        window.dispatchEvent(event);
    }
    window.components.push(dataNewObj)

    if(DEBUG_FLAG_FRAMEWORK) console.log(type, '---------------------- Починаю створювати внутрішні компоненти')
    let components = div.firstElementChild.querySelectorAll('[component]')
    components.forEach(el => {
        let data = {
            cuuid: el.getAttribute('cuuid'),
            type: el.getAttribute('component'),
            domLink: '',
            childComponents: [],
            dependencies: [],
            handlers: [],
            props: el.getAttribute('props'),
            drawingUp: 'redraw'
        }
        if(DEBUG_FLAG_FRAMEWORK) console.log('Дочірня компонента', data.type, data.props)
        if(!window[data.type]) if(DEBUG_FLAG_FRAMEWORK) console.log("Компонент " + data.type + " не знайдено");
        window.components.push(data)

        let component = createComponent(data.type, window[data.type], window.components.find(l => l.cuuid === data.cuuid))
        if(DEBUG_FLAG_FRAMEWORK) console.log('Внутрішня компонента... ', data.type, ' : ', data.cuuid, component)

        div.firstElementChild.querySelector(`[cuuid="${data.cuuid}"]`).replaceWith(component.domLink)
    })

    if(div.firstElementChild.tagName === 'VOID') div = div.firstElementChild
    dataNewObj.domLink = div.firstElementChild;

    return dataNewObj
}

function render(container, component, jobj = null){
    let Component = createComponent(component, window[component], jobj)
    if(DEBUG_FLAG_FRAMEWORK) console.log(window.components)
    if(DEBUG_FLAG_FRAMEWORK) console.log(container, component, jobj)
    container.replaceWith(Component.domLink)

    let event = new CustomEvent('render', { detail: { 'component': Component } });
    window.dispatchEvent(event);
}

function useHandler(f) {
    let n = generateRandomString()
    window.jhandler = {...window.jhandler, [n]: f}
    return n
}

function useState(obj) {
    let k = thisComponent, st = Object.keys(obj)[0]
    console.log(window.jstate)
    window.jstate[k.type] = {...obj, ...window.jstate[k.type]}
    console.log(window.jstate)
    return {[st]: window.jstate[k.type][st], ['set'+st.charAt(0).toUpperCase() + st.slice(1)]: (v) => {
            window.jstate[k.type][st] = typeof v === 'undefined' ? window.jstate[k.type][st] : v
            render(k.domLink, k.type, k)
        } }
}

function toProps(obj) {
    let name = generateRandomString()
    window.jprops[name] = obj
    return `props="${name}"`
}

function useEffect(f) {
    window.addEventListener('render', f, {once: true})
}
function onCreate(f) {
    let tc = thisComponent
    window.addEventListener('onCreate',
        e => { if(e.detail.component.type === tc.type) f(e) }, {once: true})
}
function onUpdate(f) {
    let tc = thisComponent
    window.addEventListener('onUpdate',
        e => { if(e.detail.component.type === tc.type) f(e) }, {once: true})
}
function ref(f) {

}

function unMount(fn) {
    if(DEBUG_FLAG_FRAMEWORK) console.log('Привязую unMount', thisComponent)
    let c = window.thisComponent.cuuid
    let unmount = (e) => {
        if(e.detail.listUnMount.find(f => f.cuuid === c)) fn(e)
    }
    window.addEventListener('unMount', unmount, {once: true})
}

function getChildsAll(o, list) {
    if(o && o.childComponents.length !== 0) o.childComponents.map(el => {
        let c = window.components.find(i => i.cuuid === el)
        if(c) list.push(c)
        getChildsAll(c, list)
    })
}

function unMountComponent(data) {
    let listUnMountComponent = [data], recursive
    getChildsAll(data, listUnMountComponent)

    if(!data.drawingUp) {
        let event = new CustomEvent('unMount', {detail: {'targetUnMount': data, 'listUnMount': listUnMountComponent}});
        window.dispatchEvent(event);
    }
    if(DEBUG_FLAG_FRAMEWORK) console.log('Компоненти для знищення', listUnMountComponent)
    listUnMountComponent.map((el, k) => {
        if(!data.drawingUp && k !== 0 ) delete window.jprops[el.props]
        el.handlers.map(h => delete window.jhandler[h])
        window.components = window.components.filter(i => i.cuuid !== el.cuuid)
        if(DEBUG_FLAG_FRAMEWORK) console.log('Знищено компонент... ', el.cuuid)
    })
}


function generateRandomString(){
    return Math.random().toString(20).substr(2, 8)
}

function wholePart(str){
    return str.replace(/\.([0-9].*)/g, (match) => ``)
}

function getKey(key, obj) {
    return key.split('.').reduce(function(a,b){
        return a && a[b];
    }, obj);
}


window.state = {
    constructor(initialState){
        state.route = '/'
        if(typeof initialState === "object")
            Object.keys(initialState).map(k => state[k] = initialState[k])

        if(state.arrSync) state.arrSync = [...state.arrSync]
        else state.arrSync = []
    },

    // Потрібно слідкувати щоб зміни були в правильному порядку
    update(path, value = null){
        if(typeof value === 'function') {
            value(state.getStateFromKey(path));
            console.log('Функція зміни даних...', value)
            value = null
        }
        if(typeof path === 'string') up(path)
        function up(k) {
            k = k.replace(/\[[`"'](?<tag>[0-9A-Za-z]*)['"`]\]/g, (match, tag) => `.${tag}`)
            let path = k.split('.'),
                obj = state, length = path.length - 1;
            if (path[path.length - 1] === '*') path = path.pop()

            for (let i = 1; i < length; ++i) obj = obj[path[i]];
            obj[path[length]] = value === null ? obj[path[length]] : value;

            state.syncStorage(wholePart(k));
            console.log('Синхронізую дані... ', k, " = ", value === null ? obj[path[length]] : value)
            state.dispatch(wholePart(k));
        }
    },

    /**
     * @param dataChange - шлях до обєкта який було змінено звіряємо з залежностями
     * та оприділення які компонненти перемальовувати
     */
    dispatch(dataChange){
        if(DEBUG_FLAG_FRAMEWORK) console.log('Dispatch: ', dataChange, window.components)
        window.components.map(k => {
            if(k.dependencies) k.dependencies.map(el => {
                // Точна залежність - оновлюємо тільки при зміні саме цього елементу
                // * - залежний від зміни будь-яких даних в обєкті
                let a = el.split('.')
                if( dataChange === el || (a[a.length-1] === '*' && dataChange.includes(bigPop(a).join('.'))) ) {
                    if(DEBUG_FLAG_FRAMEWORK) console.log(`Оновлюю компонент - "${k.type} : ${k.cuuid}" ...`, `Змінено: ${dataChange}`)
                    if(window.components.find(old => old.cuuid === k.cuuid)) render(k.domLink, k.type, k)
                }
                function bigPop(r) {r.pop(); return r}
            })
        })

        let event = new CustomEvent('StateDispatch', {detail: {'change': dataChange} });
        window.addEventListener('StateDispatch', e => {}, false);
        window.dispatchEvent(event);
    },

    syncStorage(sync){
        state.arrSync.map(k => {
            if(sync.includes(k)){
                let path = sync.split('.'), obj = state, length = path.length;
                for (let i = 1; i < length; ++i) obj = obj[path[i]];
                window.db.set(sync, obj, function() {})
                // localStorage.setItem('storage', {[sync]: obj})
                // chrome.storage.sync.set({[sync]: obj}, function() {})
            }
        })
    },

    fullSyncStorage(){
        state.arrSync.map(el => state.syncStorage(el))
    },

    /**
     * Оскільки використовується перерисовка так як отримання даних з Chrome.storage асинхронний процес
     * Тому використовувати функцію потрібно обережено
     * (При перевірці існування даних бажано, щоб не виникало циклічної перерисовки)
     * @param sync
     */

    getSyncStorage(sync= []){
        if( sync.length === 0 ) sync = state.arrSync;
        window.db.get(sync, (key, item) => {
            if(typeof item !== 'undefined') state.update(key, item)
        })
        /*            sync.map(el => {
                        chrome.storage.sync.get(el, items => {
                            if(items[el]) state.update(el, items[el])
                        })
                    })*/
    },

    getStateFromKey(k) {
        let path = k.split('.'),
            obj = state,
            length = path.length - 1;

        for (let i = 1; i < length; ++i) obj = obj[path[i]];
        return obj[path[length]]
    }
}

function random_between(min, max, units = 1) {
    min = min*units; max = max*units
    return Math.floor(Math.random()*(max-min+1)+min);
}

window.db = {
    constructor (callback) {
        let dbReq = indexedDB.open('myDB', 1);
        dbReq.onupgradeneeded = (event) => {
            // Зададим переменной db ссылку на базу данных
            this.db = event.target.result;
            // Создадим хранилище объектов с именем notes.
            let store = this.db.createObjectStore('store', {autoIncrement: false});
        }
        dbReq.onsuccess = (event) => {
            this.db = event.target.result;
            callback()
        }
        dbReq.onerror = (event) => {
            console.log('error opening database ' + event.target.errorCode);
        }
    },

    set (key, data, callback) {
        // Запустим транзакцию базы данных и получите хранилище объектов Store
        let tx = this.db.transaction(['store'], 'readwrite');
        let store = tx.objectStore('store');
        // Добаляем заметку в хранилище объектов
        store.put(data, key);

        // Ожидаем завершения транзакции базы данных
        tx.oncomplete = () => {
            callback()
        }
        tx.onerror = (event) => {
            console.log('error storing data ' + event.target.errorCode);
        }
    },

    get (keys, callback) {
        // Настройка хранилища объектов и транзакции
        let tx = this.db.transaction(['store'], 'readonly');
        let store = tx.objectStore('store');

        keys.map(key => {
            let req = store.get(key);
            req.onsuccess = function() {
                callback(key, req.result)
            };
        })

    }
}